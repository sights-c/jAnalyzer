/*
    jAnalyzer, reads raw TDC data (dat files) generated by jDaqLite and 
    shows data measured by a jTDC modules.
     
    Copyright (C) 2014 John Bieling <john.bieling@uni-bonn.de>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.    
*/

#include <iostream>
#include <map>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <cstring>
#include <vector>

#include <sys/time.h>
#include <stdlib.h>
#include <signal.h>
#include <termios.h>


using namespace std;


static const int maxchannels = 100;
static const int maxbins = 256;

typedef struct
{
       vector<uint32_t> hitsPerChannel[maxchannels];
}
eventdata;




 //* * * * * * * * * * * * * * * * * * * *//
 //*   H E L P E R   F U N C T I O N S   *//
 //* * * * * * * * * * * * * * * * * * * *//

bool abort_request;

void CtrlCHandler(int sig)
{
        abort_request = true;
        cout << "anceling..." << endl;
        signal(sig,SIG_IGN);  
}


 //* * * * * * * * * * * * * * * * * * * * * *//
 //*   P A R A M E T E R   H A N D L I N G   *//
 //* * * * * * * * * * * * * * * * * * * * * *//

enum PNAME {ERROR,VERBOSE};

class parameterHandle {
        private:
                struct PDATA {
                        string sShort;
                        string sLong;
                        string sDescription;
                        bool moredata;
                        uint32_t value;
                        bool flag;
                        bool allowed;
                };
                string intro;
                string outro;
                map<PNAME, PDATA> dataset;
        public:
                parameterHandle();
                void add(PNAME p, bool moredata, string l, string s, string d);
                PNAME find(string);
                bool hasMoredata(PNAME);
                void storeValue(PNAME,string);
                uint32_t get(PNAME);
                void set(PNAME);
                bool isSet(PNAME);
                void allow(PNAME);
                bool check();
                void setIntro(string);
                void setOutro(string);
                string getIntro();
                string getOutro();
                
};

parameterHandle::parameterHandle() {
        dataset.clear();
}


void parameterHandle::setIntro(string str) { intro = str; }
void parameterHandle::setOutro(string str) { outro = str; }


bool parameterHandle::hasMoredata(PNAME p) {
        return dataset.at(p).moredata;
}


void parameterHandle::storeValue(PNAME p, string value) {
        dataset.at(p).flag = true;
        if (dataset.at(p).moredata) {
                dataset.at(p).value = strtoul(value.c_str(),NULL,0);
        }
}

uint32_t parameterHandle::get(PNAME p) {
        return dataset.at(p).value;        
}

void parameterHandle::set(PNAME p) {
        dataset.at(p).flag = true;
}


bool parameterHandle::isSet(PNAME p) {
        return dataset.at(p).flag;
}


void parameterHandle::allow(PNAME p) {
        dataset.at(p).allowed = true;
}


PNAME parameterHandle::find(string needle) {
        //iterate over map and find parameterHandle
        PNAME found = ERROR;
        map<PNAME, PDATA>::iterator i;
   
        for (i = dataset.begin(); i != dataset.end(); i++) {
                if ((i->second.sShort == needle) || (i->second.sLong == needle)) {
                        found = i->first;
                        break;
                }
        }        
        return found;
}


void parameterHandle::add(PNAME p, bool m, string l, string s, string d) {
        PDATA prep;
        prep.sShort = s;
        prep.sLong = l;
        prep.sDescription = d;
        prep.moredata = m;  
        prep.value = 0;
        prep.flag = false;
        prep.allowed = false;
        dataset.insert( std::pair<PNAME,PDATA>(p,prep) );       
}



bool parameterHandle::check ()
{
        bool isOK = true;
        string dummy = "";
        
        map<PNAME, PDATA>::iterator i;
        
        for (i = dataset.begin(); i != dataset.end(); i++) {
                if (i->second.flag && !i->second.allowed) isOK = false;
        }        

        
        if (!isOK) {
                cout << intro << endl << endl;
                for (i = dataset.begin(); i != dataset.end(); i++) {
                        if (i->second.moredata) dummy = " <...>";
                        else dummy = "      ";
                        if (i->second.allowed) {
                                cout << "\t   " << i->second.sLong << "\t" << i->second.sShort << dummy << "\t : " << i->second.sDescription << endl;
                        }
                }        
                cout << endl ;
                cout << outro << endl << endl;
        }
        
        return isOK;
}



void readData (string filename, bool verbose)
{
       //Read file and store data in memory
       //----------------------------------

       ifstream datfile;
       datfile.open (filename.c_str(), ios::in | ios::binary);


       vector<eventdata> events;
       int eventcounter = 0;    

       printf("Starting to process events...\n");       
       while (true)
       {
              //read eventfifo value
              uint32_t eventfifo = 0;
              char eventbuffer[4];
              datfile.read(eventbuffer,4);
              if (!datfile.good()) break;
              
              //data has been stored using little endian-ness
              eventfifo  = (((uint32_t)eventbuffer[3]) & 0xFF) << 24;
              eventfifo |= (((uint32_t)eventbuffer[2]) & 0xFF) << 16;
              eventfifo |= (((uint32_t)eventbuffer[1]) & 0xFF) << 8;
              eventfifo |= (((uint32_t)eventbuffer[0]) & 0xFF);

              
              //look into eventfifo
              int entries_found_in_eventfifo = (eventfifo & 0x1fff);
              uint32_t eventnumber_found_in_eventfifo = ((eventfifo >> 16) & 0xffff);

              if (verbose) printf("\n Eventfifo: 0x%08X (Eventnumber: %d, datawords: %d)\n",eventfifo, eventnumber_found_in_eventfifo, entries_found_in_eventfifo);


              bool header1_found = false;
              bool header2_found = false;
              bool trailer_found = false;
              int found_filler_at = 0;
              int hits_found = 0;
              
              bool header1_not_first = false;
              bool header2_not_second = false;
              bool header_has_wrong_entries_count = false;
              bool trailer_not_last = trailer_found;
              bool filler_not_before_trailer = false;
              bool trailer_has_wrong_event_number = false;
              bool clk_without_hit = false;
              bool unknown = false;

              vector<uint32_t> hitdata;
              eventdata thisevent;
              
              //the two 16bit data words are generated as little endian by the FPGA 
              //and jDaqLite keeps that endian-ness, so we can simply read out twice as
              //much 16bit words in one go
              for (int i=0; i<entries_found_in_eventfifo*2; i++)
              {
                     //read datafifo value
                     uint32_t datafifo;
                     char databuffer[2];
                     datfile.read(databuffer,2);
                     
                     //again, data is stored with little endian-ness
                     datafifo = (((uint32_t)databuffer[1]) & 0xFF) << 8;
                     datafifo |= ((uint32_t)databuffer[0] & 0xFF);
                     if (verbose) printf(" 0x%04X : ",datafifo);
                     

                     //after trailer, we should not be here
                     if (trailer_found) trailer_not_last = true;
                                          
                     //look into 16bit datafifo for plausibility check, also put high-resolution-information in histogram                   
                     // if bit 16 == 1 -> header, clk, filler or trailer
                     // else -> hit
                     if ((datafifo & 0x8000) > 0)
                     {      
                            switch ((datafifo & 0xF000) >> 12)
                            {
                                   case 0xC: //header 1
                                   case 0xD: 
                                          header1_found = true;
                                          if (i != 0) header1_not_first = true;
                                          if ((datafifo & 0x1FFF) != (entries_found_in_eventfifo & 0x1FFF)) header_has_wrong_entries_count = true;
                                          if (verbose) printf("header 1 (number of 32bit words: %d)",datafifo & 0x1FFF);
                                   break;

                                   case 0xE: //header 2
                                   case 0xF: 
                                          header2_found = true;
                                          if (i != 1) header2_not_second = true;
                                          if (verbose) printf("header 2");
                                   break;
                                   
                                   case 0x8: //clk counter
                                   case 0x9: 
                                          if (hits_found == 0) clk_without_hit = true;
                                          else for( uint32_t h = 0; h < hitdata.size(); h++ ) 
                                          {                                               
                                                 //recombine coarse time (from clk counter) and fine time (from hitdata)
                                                //  uint32_t time = ((datafifo & 0x1FFF) << 8) | (hitdata[h] & 0xFF);
                                                //  uint32_t channel = ((hitdata[h] >> 8) & 0x7F);

                                                if (verbose) printf("  hit in ch %02d with bin value %d , clk counts %d",(datafifo & 0x7F00) >> 8, datafifo & 0xFF, datafifo & 0x1FFF);

                                          }
                                          hitdata.clear();
                                                 
                                          if (verbose) printf("clk counter");
                                   break;
                                   
                                   case 0xB: //filler
                                          found_filler_at = i;
                                          if (verbose) printf("filler");
                                   break;

                                   case 0xA: //trailer
                                          trailer_found = true;
                                          if (found_filler_at > 0 && found_filler_at != i-1) filler_not_before_trailer = true;
                                          if ((datafifo & 0xFF) != (eventnumber_found_in_eventfifo & 0xFF)) trailer_has_wrong_event_number = true;
                                          if (verbose) printf("trailer (lowest 8 bit of event number: 0x%X)",datafifo & 0xFF);
                                   break;
                                   
                                   default: 
                                          unknown = true;
                                          if (verbose) printf("UNKNOWN!");
                                   break;
                            }
                     }
                     else 
                     {
                            if (verbose) printf("  hit in ch %02d with bin value %d",(datafifo & 0x7F00) >> 8, datafifo & 0xFF);
                            hitdata.push_back(datafifo);

                            hits_found ++;
                     }
                     if (verbose) printf("\n");
                     
              }
              
              
              char *error;
              error = (char *)malloc(1000);
              sprintf(error,"%s", "");

              if (header1_not_first || !header1_found) strcat(error, "  - header1 was not (only) the first word\n");
              if (header_has_wrong_entries_count) strcat(error, "  - number of entries found in header1 does not match number of entries found in eventfifo\n");
              if (header2_not_second || !header2_found) strcat(error, "  - header2 was not (only) the second word\n");
              if (trailer_not_last || !trailer_found) strcat(error, "  - trailer was not (only) the last word\n");
              if (trailer_has_wrong_event_number) strcat(error, "  - event number found in trailer does not match event number found in eventfifo\n");
              if (filler_not_before_trailer) strcat(error, "  - filler at wrong location\n");
              if (clk_without_hit) strcat(error, "  - there was a clk counter without any preceding hits\n");
              if (unknown) strcat(error, "  - unknown word found\n");

              // always report and skip corrupted events
              if (strlen(error)>0) printf(" Event #%d of this dataset might be corrupt, the following error(s) have been found:\n%s",eventcounter,error);
              else events.push_back(thisevent);

              eventcounter++;
              if (abort_request) break;

              //in verbose mode, the detailed output is not paused, the user can pipe it into a file if he wants
              //however, if there was an error, the user should be able to investigate directly -> pause
              if (strlen(error)>0) 
              {
                     printf(" Hit Enter to continue.\n");
                     getchar();
              }
              
       }

       datfile.close();
       printf("\nProcessed %d events.\n\n",eventcounter);        
       printf("Done.\n\n");      
}










 //* * * * * * * *//
 //*   M A I N   *//
 //* * * * * * * *//

int main (int argc, char **argv) 
{
        abort_request = false;
        signal(SIGINT, (sighandler_t)&CtrlCHandler);

        std::cout << endl;
        std::cout << "jAnalyzer  Copyright (C) 2015   John Bieling (john.bieling@uni-bonn.de)" << std::endl;
        std::cout << endl;
        std::cout << "This program comes with ABSOLUTELY NO WARRANTY." << std::endl;
        std::cout << "This is free software, and you are welcome to redistribute it" << std::endl;
        std::cout << "under certain conditions." << std::endl;
        std::cout << endl;
        std::cout <<  "This tool can be used to analyze raw datasets (dat files) of a jTDC module." << std::endl;
        std::cout << endl;        
        
        
        //We need at least a filename
        string filename;
        if(argc > 1) {
                filename = string(argv[1]);
                sprintf(argv[1]," "); //so we can pass argv on the subclass
        } else {
                cout << "\tusage: jAnalyzer filename [options]" << endl << endl;
                cout << "If no options are provided, a list of all available options is shown." << endl << endl;
                exit(0);
        }
        

        //Define all possible parameters
        parameterHandle *params = new parameterHandle();
        params->setIntro("\tusage: jAnalyzer filename [options]");
        params->add(ERROR              ,false ,""              ,""     ,"");
        params->add(VERBOSE            ,false ,"--verbose       "  ,"-v"   ,"explain each dataword found");
        
        
        
        //Get all parameters - at this point we check only, if it is a valid parameter, not if it is valid for a certain subroutine
        int valid = 0;
        if(argc > 1) 
        {
                for (int i=2;i<argc;i++) 
                {
                        PNAME p = params->find(string(argv[i]));
                        if (p != ERROR) { 
                                valid++;                                 
                                if (params->hasMoredata(p)) {
                                        if (i+2>argc) { valid = 0; break; } //no "next" argv to get value from
                                        else i++; //jump to value, and ignore as parameter next time
                                }

                                params->storeValue(p,string(argv[i]));                                
                        }
                        else { valid = 0; break; } //as soon as we find an invalid parameter, abort
                }                      
        }              
        if (argc <= 1 || valid == 0) params->set(ERROR); 
                    
        params->allow(VERBOSE);       
        
        if (params->check()) 
        {                           
                readData (filename, params->isSet(VERBOSE));
        }
           
        return 0;
}
